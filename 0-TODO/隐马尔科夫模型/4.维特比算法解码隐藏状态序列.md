# 维特比算法解码隐藏状态序列

文章地址：https://www.cnblogs.com/pinard/p/6991852.html

在本篇我们会讨论HMM模型最后一个问题的求解，即即给定模型和观测序列，求给定观测序列条件下，最可能出现的对应的隐藏状态序列。在阅读本篇前，建议先阅读这个系列的第一篇以熟悉HMM模型。

　　　　HMM模型的解码问题最常用的算法是维特比算法，当然也有其他的算法可以求解这个问题。同时维特比算法是一个通用的求序列最短路径的动态规划算法，也可以用于很多其他问题，比如之前讲到的[文本挖掘的分词原理](http://www.cnblogs.com/pinard/p/6677078.html)中我们讲到了单独用维特比算法来做分词。

　　　　本文关注于用维特比算法来解码HMM的的最可能隐藏状态序列。

# 1. HMM最可能隐藏状态序列求解概述

　　　　在HMM模型的解码问题中，给定模型λ=(A,B,Π)λ=(A,B,Π)和观测序列O={o1,o2,...oT}O={o1,o2,...oT}，求给定观测序列O条件下，最可能出现的对应的状态序列I∗={i∗1,i∗2,...i∗T}I∗={i1∗,i2∗,...iT∗},即P(I∗|O)P(I∗|O)要最大化。

　　　　一个可能的近似解法是求出观测序列OO在每个时刻tt最可能的隐藏状态i∗tit∗然后得到一个近似的隐藏状态序列I∗={i∗1,i∗2,...i∗T}I∗={i1∗,i2∗,...iT∗}。要这样近似求解不难，利用[隐马尔科夫模型HMM（二）前向后向算法评估观察序列概率](http://www.cnblogs.com/pinard/p/6955871.html)中第五节的定义：在给定模型λλ和观测序列OO时，在时刻tt处于状态qiqi的概率是γt(i)γt(i)，这个概率可以通过HMM的前向算法与后向算法计算。这样我们有：i∗t=argmax1≤i≤N[γt(i)],t=1,2,...Tit∗=argmax1≤i≤N[γt(i)],t=1,2,...T

　　　　近似算法很简单，但是却不能保证预测的状态序列是整体是最可能的状态序列，因为预测的状态序列中某些相邻的隐藏状态可能存在转移概率为0的情况。

　　　　而维特比算法可以将HMM的状态序列作为一个整体来考虑，避免近似算法的问题，下面我们来看看维特比算法进行HMM解码的方法。

# 2. 维特比算法概述

　　　　维特比算法是一个通用的解码算法，是基于动态规划的求序列最短路径的方法。在[文本挖掘的分词原理](http://www.cnblogs.com/pinard/p/6677078.html)中我们已经讲到了维特比算法的一些细节。

　　　　既然是动态规划算法，那么就需要找到合适的局部状态，以及局部状态的递推公式。在HMM中，维特比算法定义了两个局部状态用于递推。

　　　　第一个局部状态是在时刻tt隐藏状态为ii所有可能的状态转移路径i1,i2,...iti1,i2,...it中的概率最大值。记为δt(i)δt(i):δt(i)=maxi1,i2,...it−1P(it=i,i1,i2,...it−1,ot,ot−1,...o1|λ),i=1,2,...Nδt(i)=maxi1,i2,...it−1P(it=i,i1,i2,...it−1,ot,ot−1,...o1|λ),i=1,2,...N

　　　　由δt(i)δt(i)的定义可以得到δδ的递推表达式：δt+1(i)=maxi1,i2,...itP(it+1=i,i1,i2,...it,ot+1,ot,...o1|λ)=max1≤j≤N[δt(j)aji]bi(ot+1)(1)(2)(1)δt+1(i)=maxi1,i2,...itP(it+1=i,i1,i2,...it,ot+1,ot,...o1|λ)(2)=max1≤j≤N[δt(j)aji]bi(ot+1)

　　　　第二个局部状态由第一个局部状态递推得到。我们定义在时刻tt隐藏状态为ii的所有单个状态转移路径(i1,i2,...,it−1,i)(i1,i2,...,it−1,i)中概率最大的转移路径中第t−1t−1个节点的隐藏状态为Ψt(i)Ψt(i),其递推表达式可以表示为：Ψt(i)=argmax1≤j≤N[δt−1(j)aji]Ψt(i)=argmax1≤j≤N[δt−1(j)aji]

　　　　有了这两个局部状态，我们就可以从时刻0一直递推到时刻TT，然后利用Ψt(i)Ψt(i)记录的前一个最可能的状态节点回溯，直到找到最优的隐藏状态序列。

# 3. 维特比算法流程总结

　　　　现在我们来总结下维特比算法的流程：

　　　　输入：HMM模型λ=(A,B,Π)λ=(A,B,Π)，观测序列O=(o1,o2,...oT)O=(o1,o2,...oT)

　　　　输出：最有可能的隐藏状态序列I∗={i∗1,i∗2,...i∗T}I∗={i1∗,i2∗,...iT∗}

　　　　1）初始化局部状态：δ1(i)=πibi(o1),i=1,2...Nδ1(i)=πibi(o1),i=1,2...NΨ1(i)=0,i=1,2...NΨ1(i)=0,i=1,2...N

　　　　2) 进行动态规划递推时刻t=2,3,...Tt=2,3,...T时刻的局部状态：δt(i)=max1≤j≤N[δt−1(j)aji]bi(0t),i=1,2...Nδt(i)=max1≤j≤N[δt−1(j)aji]bi(0t),i=1,2...NΨt(i)=argmax1≤j≤N[δt−1(j)aji],i=1,2...NΨt(i)=argmax1≤j≤N[δt−1(j)aji],i=1,2...N

　　　　3) 计算时刻TT最大的δT(i)δT(i),即为最可能隐藏状态序列出现的概率。计算时刻TT最大的Ψt(i)Ψt(i),即为时刻TT最可能的隐藏状态。P∗=max1≤j≤NδT(i)P∗=max1≤j≤NδT(i)i∗T=argmax1≤j≤N[δT(i)]iT∗=argmax1≤j≤N[δT(i)]

　　　　4) 利用局部状态Ψ(i)Ψ(i)开始回溯。对于t=T−1,T−2,...,1t=T−1,T−2,...,1：i∗t=Ψt+1(i∗t+1)it∗=Ψt+1(it+1∗)

　　　　最终得到最有可能的隐藏状态序列I∗={i∗1,i∗2,...i∗T}I∗={i1∗,i2∗,...iT∗}

# 4. HMM维特比算法求解实例

　　　　下面我们仍然用[隐马尔科夫模型HMM（一）HMM模型](http://www.cnblogs.com/pinard/p/6945257.html)中盒子与球的例子来看看HMM维特比算法求解。

　　　　我们的观察集合是:V={红，白}，M=2V={红，白}，M=2

　　　　我们的状态集合是：Q={盒子1，盒子2，盒子3}，N=3Q={盒子1，盒子2，盒子3}，N=3

　　　　而观察序列和状态序列的长度为3.

　　　　初始状态分布为：Π=(0.2,0.4,0.4)TΠ=(0.2,0.4,0.4)T

　　　　状态转移概率分布矩阵为：

A=⎛⎜⎝0.50.20.30.30.50.20.20.30.5⎞⎟⎠A=(0.50.20.30.30.50.20.20.30.5)

 　　　　观测状态概率矩阵为：

B=⎛⎜⎝0.50.50.40.60.70.3⎞⎟⎠B=(0.50.50.40.60.70.3)

　　　　球的颜色的观测序列:O={红，白，红}O={红，白，红}

　　　　按照我们上一节的维特比算法，首先需要得到三个隐藏状态在时刻1时对应的各自两个局部状态，此时观测状态为1：

δ1(1)=π1b1(o1)=0.2×0.5=0.1δ1(1)=π1b1(o1)=0.2×0.5=0.1

δ1(2)=π2b2(o1)=0.4×0.4=0.16δ1(2)=π2b2(o1)=0.4×0.4=0.16

δ1(3)=π3b3(o1)=0.4×0.7=0.28δ1(3)=π3b3(o1)=0.4×0.7=0.28

Ψ1(1)=Ψ1(2)=Ψ1(3)=0Ψ1(1)=Ψ1(2)=Ψ1(3)=0

　　　　现在开始递推三个隐藏状态在时刻2时对应的各自两个局部状态，此时观测状态为2：

δ2(1)=max1≤j≤3[δ1(j)aj1]b1(o2)=max1≤j≤3[0.1×0.5,0.16×0.3,0.28×0.2]×0.5=0.028δ2(1)=max1≤j≤3[δ1(j)aj1]b1(o2)=max1≤j≤3[0.1×0.5,0.16×0.3,0.28×0.2]×0.5=0.028

Ψ2(1)=3Ψ2(1)=3

δ2(2)=max1≤j≤3[δ1(j)aj2]b2(o2)=max1≤j≤3[0.1×0.2,0.16×0.5,0.28×0.3]×0.6=0.0504δ2(2)=max1≤j≤3[δ1(j)aj2]b2(o2)=max1≤j≤3[0.1×0.2,0.16×0.5,0.28×0.3]×0.6=0.0504

Ψ2(2)=3Ψ2(2)=3

δ2(3)=max1≤j≤3[δ1(j)aj3]b3(o2)=max1≤j≤3[0.1×0.3,0.16×0.2,0.28×0.5]×0.3=0.042δ2(3)=max1≤j≤3[δ1(j)aj3]b3(o2)=max1≤j≤3[0.1×0.3,0.16×0.2,0.28×0.5]×0.3=0.042

Ψ2(3)=3Ψ2(3)=3

　　　　继续递推三个隐藏状态在时刻3时对应的各自两个局部状态，此时观测状态为1：

δ3(1)=max1≤j≤3[δ2(j)aj1]b1(o3)=max1≤j≤3[0.028×0.5,0.0504×0.3,0.042×0.2]×0.5=0.00756δ3(1)=max1≤j≤3[δ2(j)aj1]b1(o3)=max1≤j≤3[0.028×0.5,0.0504×0.3,0.042×0.2]×0.5=0.00756

Ψ3(1)=2Ψ3(1)=2

δ3(2)=max1≤j≤3[δ2(j)aj2]b2(o3)=max1≤j≤3[0.028×0.2,0.0504×0.5,0.042×0.3]×0.4=0.01008δ3(2)=max1≤j≤3[δ2(j)aj2]b2(o3)=max1≤j≤3[0.028×0.2,0.0504×0.5,0.042×0.3]×0.4=0.01008

Ψ3(2)=2Ψ3(2)=2

δ3(3)=max1≤j≤3[δ2(j)aj3]b3(o3)=max1≤j≤3[0.028×0.3,0.0504×0.2,0.042×0.5]×0.7=0.0147δ3(3)=max1≤j≤3[δ2(j)aj3]b3(o3)=max1≤j≤3[0.028×0.3,0.0504×0.2,0.042×0.5]×0.7=0.0147

Ψ3(3)=3Ψ3(3)=3

　　　　此时已经到最后的时刻，我们开始准备回溯。此时最大概率为δ3(3)δ3(3),从而得到i∗3=3i3∗=3

　　　　由于Ψ3(3)=3Ψ3(3)=3,所以i∗2=3i2∗=3, 而又由于Ψ2(3)=3Ψ2(3)=3,所以i∗1=3i1∗=3。从而得到最终的最可能的隐藏状态序列为：(3,3,3)(3,3,3)

# 5. HMM模型维特比算法总结

　　　　如果大家看过之前写的[文本挖掘的分词原理](http://www.cnblogs.com/pinard/p/6677078.html)中的维特比算法，就会发现这两篇之中的维特比算法稍有不同。主要原因是在中文分词时，我们没有观察状态和隐藏状态的区别，只有一种状态。但是维特比算法的核心是定义动态规划的局部状态与局部递推公式，这一点在中文分词维特比算法和HMM的维特比算法是相同的，也是维特比算法的精华所在。

　　　　维特比算法也是寻找序列最短路径的一个通用方法，和dijkstra算法有些类似，但是dijkstra算法并没有使用动态规划，而是贪心算法。同时维特比算法仅仅局限于求序列最短路径，而dijkstra算法是通用的求最短路径的方法。